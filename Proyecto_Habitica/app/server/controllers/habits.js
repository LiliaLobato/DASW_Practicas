"use strict";

class HabitException{
	constructor(errorMessage){
		this.errorMessage = errorMessage;
	}
}

class Habit{
	constructor(title, difficulty, tagId, reset, bntCnt, status, streak) {
        this._id = generateId('habit');
        this.userId = //sesionStorage($userId)
        this.title = title
        //this.difficulty = difficulty //pendiente
        this.tag = tag
        //this.reset = reset //user will have a bnt to reset to 0
        // this.bntCnt = bntCnt //negative did not make sense :D
        this.counter = counter //status se obtiene de streak
    }
    //id
    get id() {
        return this._id;
    }
    set id(val) {
    	throw new HabitException('id have to be autogenerated.');
    }
    //title
    get title() {
        return this._title;
    }
    set title(val) {
    	if(typeof val !== "string" || val == ''){
    		throw new HabitException('Habit title cannot be empty.');
    	}
        this._title = val;
    }
    //difficulty
    get difficulty() {
        return this._difficulty;
    }
    set difficulty(val) {
        if( val == '' || val === undefined){
            this._difficulty = "easy";
        } else {
            if(typeof val !== "string"){
                throw new HabitException('difficulty cannot be empty.');
            }
            this._difficulty = val;
        }
    }
    //tagId
    get tagId() {
        return this._tagId;
    }
    set tagId(val) {
        if(typeof val !== "string" && val !== undefined){
            throw new HabitException('tagId is not valid.');
        }
        if(val === undefined){
            this._tagId = '';
        }else{
            this._tagId = val;
        }
    }
    //reset
    get reset() {
        return this._reset;
    }
    set reset(val) {
        this._reset = val;
        if( val == '' || val === undefined){
            this._reset = "weekly";
        } else {
            if(typeof val !== "string"){
                throw new HabitException('reset cannot be empty.');
            }
            this._reset = val;
        }
    }
    //bntCnt
    get bntCnt() {
        return this._bntCnt;
    }
    set bntCnt(val) {
        this._bntCnt = [];
        if(Array.isArray(val)){
            for(let bnt of val){
                if(bnt !== "positive" && bnt !== "negative" && bnt !== ''){
                    throw new HabitException('bntCnt not valid.');
                }
                this._bntCnt.push(bnt);
            }
        } else {
            if(val == ''  || val === undefined){
                val = "positive";
            }
            if(val !== "positive" && val !== "negative" && val !== ''){
                throw new HabitException('bntCnt not valid.');
            }
            this._bntCnt.push(val);
        }
    }
    //status
    get status() {
        return this._status;
    }
    set status(val) {
        this._status = val;
        if( val == ''  || val === undefined){
            this._status = "weak";
        } else {
            if(val !== "weak" && val !== "strong"){
                throw new HabitException('status not valid.');
            }
            if(typeof val !== "string"){
                throw new HabitException('status cannot be empty.');
            }
            this._status = val;
        }
    }
    //streak
    get streak() {
        return this._streak;
    }
    set streak(val) {
        if(val === undefined){
            this._streak = 0;
        } else {
            if(typeof val !== "number" || val < 0){
            throw new HabitException('streak cannot be negative or not number.');
            }
            this._streak = val;
        }
    }

    //Convertimos el String de JSON recibido 
    //en una nueva instancia de Habito
    static createFromJson(jsonValue){
    	let obj = JSON.parse(jsonValue);
    	return Habit.createFromObject(obj);
    }

    //Convertimos el objeto recibido en una
    //nueva instancia de Habito

    //le entra algo como let a = {'bntCnt': 15};
    static createFromObject(obj){
    	let newHabit = {};
    	Object.assign(newHabit, obj); //clone object and handle
    	Habit.cleanObject(newHabit);
    	//Falta ir pasando los valores a un Habito que pertenezca a la clase
    	let habit = new Habit(newHabit['title'], newHabit['difficulty'], newHabit['tagId'], newHabit['reset'], newHabit['bntCnt'], newHabit['status'], newHabit['streak']);
    	return habit;
    }

    //Limpiamos el objeto recibido de todos
    //aquellos valores ajenos a la clase Habit
    static cleanObject(obj){
    	const HabitProperties = ['title', 'difficulty', 'tagId', 'reset', 'bntCnt', 'status', 'streak'];
        
        for (let prop in obj){
    		//if prop not in HabitProperties
    		if(HabitProperties.indexOf(prop) == -1){
            	delete obj[prop];
            }
    	}
    }


}
