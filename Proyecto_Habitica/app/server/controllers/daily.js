"use strict";

const utils = require('./utils');

class DailyException{
	constructor(errorMessage){
		this.errorMessage = errorMessage;
	}
}

class Daily{
	constructor(userEmail, title, difficulty, tag, validOn, updatedAt, completed, counter) {
        this._id = utils.generateId('daily');
        this.userEmail = userEmail
        this.title = title
        this.difficulty = difficulty 
        this.tag = tag
        this.validOn = validOn //este es un array de strings ['mon','tue']
        this.updatedAt = updatedAt //last date when it was udpated (class guarda un string getdate() => 22/11/2021 )
        this.completed = completed //true == hecho, flase == not done
        this.counter = counter //status se obtiene de counter
    }
    //id
    get id() {
        return this._id;
    }
    set id(val) {
    	throw new DailyException('id have to be autogenerated.');
    }
    //title
    get title() {
        return this._title;
    }
    set title(val) {
    	if(typeof val !== "string" || val == ''){
    		throw new DailyException('Daily title cannot be empty.');
    	}
        this._title = val;
    }
    //userEmail
    get userEmail() {
        return this._userEmail;
    }
    set userEmail(val) {
        if(typeof val !== "string" || val == ''){
            throw new DailyException('Daily userEmail cannot be empty.');
        }
        this._userEmail = val;
    }
    //updatedAt
    get updatedAt() {
        return this._updatedAt;
    }
    set updatedAt(val) {
        if(val == '' || val === undefined){
            this._updatedAt = utils.getTodayDate();
        } else {
            if(typeof val !== "string"){
                throw new DailyException('date cannot be empty.');
            }
            this._updatedAt = val;
        }
    }
    //difficulty
    get difficulty() {
        return this._difficulty;
    }
    set difficulty(val) {
        if( val == '' || val === undefined){
            this._difficulty = "easy";
        } else {
            if(typeof val !== "string"){
                throw new DailyException('difficulty cannot be empty.');
            }
            this._difficulty = val;
        }
    }
    //completed
    get completed() {
        return this._completed;
    }
    set completed(val) {
        if( val == '' || val === undefined){
            this._completed = false;
        } else {
            if(typeof val !== "boolean"){
                throw new DailyException('completed has to be a boolean.');
            }
            this._completed = val;
        }
    }
    //tag
    get tag() {
        return this._tag;
    }
    set tag(val) {
        if(typeof val !== "string" && val !== undefined){
            throw new DailyException('tag is not valid.');
        }
        if(val === undefined){
            this._tag = '';
        }else{
            this._tag = val;
        }
    }
    //validOn
    get validOn() {
        return this._validOn;
    }
    set validOn(val) {
        this._validOn = [];
        if(Array.isArray(val)){
            for(let day of val){
                if(day !== "mon" && day !== "tue" && day !== "wed" && day !== "thu" &&
                   day !== "fri" && day !== "sat" && day !== "sun" && val !== ''){
                    throw new DailyException('day of validOn not valid.');
                }
                this._validOn.push(day);
            }
        } else {
            if(val == ''  || val === undefined){
                this._validOn = ['mon','tue','wed','thu','fri','sat','sun'];
            } else if(val !== "mon" && val !== "tue" && val !== "wed" && val !== "thu" &&
               val !== "fri" && val !== "sat" && val !== "sun" && val !== ''){
                throw new DailyException('day of validOn not valid.');
            } else {
                this._validOn.push(val);
            }
        }
    }
    //counter
    get counter() {
        return this._counter;
    }
    set counter(val) {
        if(val === undefined){
            this._counter = 0;
        } else {
            if(typeof val !== "number" || val < 0){
            throw new DailyException('counter cannot be negative or not number.');
            }
            this._counter = val;
        }
    }

    //Convertimos el String de JSON recibido 
    //en una nueva instancia de Dailyo
    static createFromJson(jsonValue){
    	let obj = JSON.parse(jsonValue);
    	return Daily.createFromObject(obj);
    }

    //Convertimos el objeto recibido en una
    //nueva instancia de Dailyo

    //le entra algo como let a = {'bntCnt': 15};
    static createFromObject(obj){
    	let newDaily = {};
    	Object.assign(newDaily, obj); //clone object and handle
    	Daily.cleanObject(newDaily);
        if(newDaily instanceof Daily){
            return newDaily;
        } else {
        	//Falta ir pasando los valores a un Dailyo que pertenezca a la clase
        	let daily = new Daily(newDaily['userEmail'], newDaily['title'], newDaily['difficulty'], newDaily['tag'], 
                                  newDaily['validOn'], newDaily['updatedAt'], newDaily['completed'], newDaily['counter']);
        	return daily;
        }
    }

    //Limpiamos el objeto recibido de todos
    //aquellos valores ajenos a la clase Daily
    static cleanObject(obj){
    	const DailyProperties = ['userEmail', 'title', 'difficulty', 'tag', 'validOn', 'updatedAt', 'completed', 'counter'];

    	for (let prop in obj){
            let prop_clean = prop.replace(/_/g, "");
            Object.defineProperty(obj, prop_clean,
                Object.getOwnPropertyDescriptor(obj, prop));
    		//if prop not in DailyProperties
    		if(DailyProperties.indexOf(prop) == -1){
            	delete obj[prop];
            }
    	}
    }
}

module.exports = Daily;
