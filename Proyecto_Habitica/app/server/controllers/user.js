"use strict";

class userDataException{
	constructor(errorMessage){
		this.errorMessage = errorMessage;
	}
}

class userData{
	constructor(){
        this._id = generateId('user');
        this.avatarImg = avatarImg
        this.avatarName = avatarName
        this.avatarLevel = avatarLevel
        this.avatarCoins = avatarCoins
        this.avatarHealth = avatarHealth
        this.avatarExp = avatarExp
		this.habitId = [];
        this.dialyId = [];
        this.todoId = [];
        this.tagId = [];
	}
    //id
    get id() {
        return this._id;
    }
    set id(val) {
        throw new DailyException('id have to be autogenerated.');
    }
    //avatarImg
    get avatarImg() {
        return this._avatarImg;
    }
    set avatarImg(val) {
        if(typeof val !== "string" || val == ''){
            throw new DailyException('Daily avatarImg cannot be empty.');
        }
        this._avatarImg = val;
    }
    //avatarName
    get avatarName() {
        return this._avatarName;
    }
    set avatarName(val) {
        if(typeof val !== "string" || val == ''){
            throw new DailyException('Daily avatarName cannot be empty.');
        }
        this._avatarName = val;
    }
    //avatarLevel
    get avatarLevel() {
        return this._avatarLevel;
    }
    set avatarLevel(val) {
        if(typeof val !== "number" || val < 0){
            throw new DailyException('avatarLevel cannot be negative or not number.');
        }
        this._avatarLevel = val;
    }
    //avatarCoins
    get avatarCoins() {
        return this._avatarCoins;
    }
    set avatarCoins(val) {
        if(typeof val !== "number" || val < 0){
            throw new DailyException('avatarCoins cannot be negative or not number.');
        }
        this._avatarCoins = val;
    }
    //avatarHealth
    get avatarHealth() {
        return this._avatarHealth;
    }
    set avatarHealth(val) {
        if(typeof val !== "number" || val < 0){
            throw new DailyException('avatarHealth cannot be negative or not number.');
        }
        this._avatarHealth = val;
    }
    //avatarExp
    get avatarExp() {
        return this._avatarExp;
    }
    set avatarExp(val) {
        if(typeof val !== "number" || val < 0){
            throw new DailyException('avatarExp cannot be negative or not number.');
        }
        this._avatarExp = val;
    }



	//productProxies
    get productProxies() {
        return this._productProxies;
    }
    set productProxies(val) {
    	throw new userDataException('Proxies can not be set manually.');
    }

	//products
    get products() {
        return this._products;
    }
    set products(val) {
    	//creamos arreglo vacio
        this._products = [];
    	if(typeof val === 'String'){
    		val = JSON.parse(val);
    	}

        if(Array.isArray(val)){
            for(let product of val){
                //remove first char of every prop
                if(product instanceof Product){
                    this._products.push(product);
                } else {
                    this._products.push(Product.createFromObject(product));
                }
            }
        } else {
            if(product instanceof Product){
                this._products.push(val);
            } else {
                this._products.push(Product.createFromObject(val));
            }
        }
    }

    addItem(productUUID, newAmount){
        if (newAmount == 0) return; //ignore empty items
    	if (newAmount < 0) throw new userDataException('Amount of items to add must be a positive number');
    	let agregado = false;

        //check if the item is already in productProxies[]
        for (let prox in this._productProxies){
            //if it is, update accordingly
            if(productUUID == this._productProxies[prox].productUUID){
                this._productProxies[prox].amount = this._productProxies[prox].amount + newAmount;
                agregado = true;
                break;
            }
        }
        //if not, create item in productProxies[]
        if(!agregado){
            let proxie = new ProductProxy(productUUID,newAmount);
            this._productProxies.push(proxie);
        }
    }

    updateItem(productUUID, newAmount){
    	if (newAmount == 0) this.removeItem(productUUID);
    	if (newAmount < 0) throw new userDataException('Amount of items to update must be a positive number');
        let agregado = false;

        //check if the item is in productProxies[]
        for (let prox in this._productProxies){
            //if it is, update accordingly
            if(productUUID == this._productProxies[prox].productUUID){
                this._productProxies[prox].amount = newAmount;
                agregado = true;
                break;
            }
        }
        //if not, add it 
        if(!agregado){
            this.addItem(productUUID, newAmount);
        }
    }
    
    removeItem(productUUID){
    	//remove _productUUID from productProxies[]
        for (let prox in this._productProxies){ 
            if(productUUID == this._productProxies[prox].productUUID){
                this._productProxies.splice(prox,1);
                break;
            }
        }
    }
    
    calculateTotal(){
    	let total = 0;
        //creamos el products[]
        this._products = (getProducts());
        for(let prox in this._productProxies){
            for(let prod in this.products){
                if(this.products[prod].uuid == this.productProxies[prox].productUUID ){
                    console.log(this.products[prod].title, ": ", this.products[prod].pricePerUnit,"x",this.productProxies[prox].amount)
                    total = total + (this.products[prod].pricePerUnit * this.productProxies[prox].amount)
                }
            }
        }
        //buscamos el valor en products y lo multiplicamos por la cantidad del proxy
    	return total;
    }
}
